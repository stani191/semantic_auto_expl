/**
 * DoorStateChecker.cpp
 * Checks states of doors (open/closed) using map information
 *
 * @author Matej Stanic (m.stanic@student.uibk.ac.at)
 * @version 1.0
 * @date 05.06.2017
 */

#include "semantic_mapping/DoorStateChecker.h"

/**
 * @brief DoorStateChecker::DoorStateChecker
 * Constructor.
 */
DoorStateChecker::DoorStateChecker(ros::NodeHandle &n){
    map_sub = n.subscribe("map", 50, &DoorStateChecker::mapCallback, this);
}

/**
 * @brief DoorStateChecker::~DoorStateChecker
 * Destructor.
 */
DoorStateChecker::~DoorStateChecker(){
}

/**
 * @brief DoorStateChecker::midPoint
 * Calculates the midpoint between two points.
 */
geometry_msgs::PointStamped DoorStateChecker::midPoint(const geometry_msgs::PointStamped p1, const geometry_msgs::PointStamped p2) {
    geometry_msgs::PointStamped mid;
    mid.header = p1.header;
    mid.point.x = (p1.point.x + p2.point.x)/2;
    mid.point.y = (p1.point.y + p2.point.y)/2;
    mid.point.z = (p1.point.z + p2.point.z)/2;

    return mid;
}

/**
 * @brief DoorStateChecker::euclideanDistance
 * Calculates the Euclidean distance between two points.
 */
double DoorStateChecker::euclideanDistance(const cv::Point2f p1, const geometry_msgs::PointStamped p2) {
    return (sqrt(pow(p1.x-p2.point.x,2)+pow(p1.y-p2.point.y,2)));
}

/**
 * @brief DoorStateChecker::euclideanDistance
 * Calculates the Euclidean distance between two points.
 */
double DoorStateChecker::euclideanDistance(const geometry_msgs::Point p1, const geometry_msgs::Point p2) {
    return (sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2)+pow(p1.z-p2.z,2)));
}

/**
 * @brief DoorStateChecker::mapToPixelCoords
 * Converts given robot map position (map frame) to position in map matrix (pixels)
 * @param point
 */
geometry_msgs::PointStamped DoorStateChecker::mapToPixelCoords(geometry_msgs::PointStamped point){
    geometry_msgs::PointStamped result;
    result.header = point.header;
    result.point.x = (point.point.x - mapOrigin.x) / mapResolution;
    result.point.y = (point.point.y - mapOrigin.y) / mapResolution;
    result.point.z = (point.point.z - mapOrigin.z) / mapResolution;
    return result;
}

/**
 * @brief DoorStateChecker::mapCallback
 * Map listener. Whenever a new map is generated by gmapping it is saved in OpenCV Mat type.
 * The map is then used as input for the target selection algorithm.
 */
void DoorStateChecker::mapCallback(const nav_msgs::OccupancyGrid msg){
    mapOrigin = msg.info.origin.position;
    mapResolution = msg.info.resolution;
    mapWidth = msg.info.width;
    mapHeight = msg.info.height;
    dyn_map = cv::Mat::zeros( msg.info.width, msg.info.height, CV_8UC1);
    for(int i = 0; i < dyn_map.rows; i++){
        for(int j = 0; j < dyn_map.cols; j++){
            if((int) msg.data[i+msg.info.width*j] == -1){
               dyn_map.at<uchar>(i,j) = 100;
            } else if((int) msg.data[i+msg.info.width*j] == 100){
               dyn_map.at<uchar>(i,j) = 0;
            } else if((int) msg.data[i+msg.info.width*j] == 0){
               dyn_map.at<uchar>(i,j) = 255;
            } else {
               ROS_ERROR("map conversion error...");
            }
       }
    }
}

/**
 * @brief DoorStateChecker::checkDoorState
 * Checks the state of a door (open/closed) by examining the number of occupied cells within
 * the door range. The door is split into two halves to take care of position errors.
 * @param door - door message
 */
void DoorStateChecker::checkDoorState(semantic_mapping_msgs::DoorMessage &door){
    // 1. Transform door start/end points into map coordinates
    geometry_msgs::PointStamped pt_start_map;
    geometry_msgs::PointStamped pt_end_map;
    if(tf_listener.waitForTransform("map","world", ros::Time(0), ros::Duration(2.0))){
        tf_listener.transformPoint("map", door.pt_start, pt_start_map);
        tf_listener.transformPoint("map", door.pt_end, pt_end_map);
        // Split door in 2 equal halves - find center points
        geometry_msgs::PointStamped doorCenterPoint = midPoint(pt_start_map, pt_end_map);
        geometry_msgs::PointStamped leftCenterPoint = mapToPixelCoords(midPoint(pt_start_map, doorCenterPoint));
        geometry_msgs::PointStamped rightCenterPoint = mapToPixelCoords(midPoint(doorCenterPoint, pt_end_map));
        doorCenterPoint = mapToPixelCoords(doorCenterPoint);

        double leftDist = euclideanDistance(doorCenterPoint.point, leftCenterPoint.point);
        double rightDist = euclideanDistance(doorCenterPoint.point, rightCenterPoint.point);
        int occupiedLeft = 0;
        int occupiedRight = 0;

        // for every half - check if more than x occupied cells in their radius
        for(int i = 0; i < dyn_map.rows; i++){
                for(int j = 0; j < dyn_map.cols; j++){
                    if (dyn_map.at<uchar>(i,j) == 0){
                        cv::Point2f tmp(j,i);
                        if (euclideanDistance(tmp, leftCenterPoint) < leftDist){
                            occupiedLeft++;
                        }
                        if (euclideanDistance(tmp, rightCenterPoint) < rightDist){
                            occupiedRight++;
                        }
                    }
                }
        }
        // if there are more than x cells in both cubes declare door as closed, else as open
        if (occupiedLeft > occupiedThresh && occupiedRight > occupiedThresh){
            ROS_INFO("Door changed to closed - occL = %d | occR = %d", occupiedLeft, occupiedRight);
            door.state = "closed";
        } else {
            door.state = "open";
        }
    } else {
        ROS_WARN("transform error at checkDoorState");
    }
}

/**
 * @brief DoorStateChecker::checkDoorStates
 * Helper function for checkDoorState
 * @param doors - list of doors
 */
void DoorStateChecker::checkDoorStates(std::vector<semantic_mapping_msgs::DoorMessage> &doors){
    for (semantic_mapping_msgs::DoorMessage &door : doors){
        checkDoorState(door);
    }
}
